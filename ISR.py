# 2.1. Разработать скрипт с функцией, которая строит таблицу истинности для логического выражения 
#      (по вариантам) для двух и трех аргументов (используются различные наборы значений аргументов). 
_____________________________________________________________________________________________________
# Вариант: 6
def firstLine(f):
  print('\u250C', end='')
  for tab in range(len(f) - 1):
    print(('\u2500'*(len(f[tab]) + 2) + '\u252C'), end='')
  print('\u2500'*(len(f[-1]) + 2) + '\u2510')
  # Названия столбцов
  for num in f:
    print('\u2502' + ' ' + num + ' ', end = '')
  print('\u2502')

def lastLine(f):
  print('\u2514', end='')
  for tab in range(len(f) - 1):
    print(('\u2500'*(len(f[tab]) + 2) + '\u2534'), end='')
  print('\u2500'*(len(f[-1]) + 2) + '\u2518')

def prom(f):
  print('\u251C', end ='')
  for tab in range(len(f) - 1):
    print(('\u2500'*(len(f[tab]) + 2) + '\u253C'), end='')
  print('\u2500'*(len(f[-1]) + 2) + '\u2524')

def func2(func_in, A, B, z):
  k = func_in(A, B)
  print('\u2502', end = '')
  for i in range(len(k) - 1):
    print('',k[i], '\u2502', end = '')
  print(' ' * ((z + 2)//2), end='')
  print(k[-1], end='')
  print(' ' * (z + 1 - (z + 2)//2), end='')
  print('\u2502')

def func3(func_in, A, B,C, z):
  k = func_in(A, B, C)
  print('\u2502', end = '')
  for i in range(len(k) - 1):
    print('',k[i], '\u2502', end = '')
  print(' ' * ((z + 2)//2), end='')
  print(k[-1], end='')
  print(' ' * (z + 1 - (z + 2)//2), end='')
  print('\u2502')  

A2 = [False, False, True, True]
B2 = [False, True, False, True]

A3 = [False, False, False, False, True, True, True, True]
B3 = [False, False, True, True, False, False, True, True]
C3 = [False, True, False, True, False, True, False, True]

# Постройте таблицу истинности для: 
# 4. (A∨B)∧(¬A∨¬B)
def function_4(A, B):
  return [int(A),int(B), int((A or B) and ((not(A)) or (not(B))))]
m_4 = ['A', 'B', '(A˅B)˄(¬A˅¬B)']
firstLine(m_4)
prom(m_4)
for i in range(len(A2) - 1):
  func2(function_4, A2[i], B2[i], len(m_4[-1]))
  prom(m_4)
func2(function_4, A2[-1], B2[-1], len(m_4[-1]))
lastLine(m_4)

# Постройте таблицу истинности для: 
# 6. ((C∨B)→B)∧(A∧ B)→B
def function_6(A, B, C):
  return [int(A), int(B), int(C), int(not(((not((C or B)) or B)) and (A and B)) or B)]
m_6 = ['A', 'B', 'C', '((C˅B)→B)˄(A˄B)→B']
firstLine(m_6)
prom(m_6)
for i in range(len(A3) - 1):
  func3(function_6, A3[i], B3[i], C3[i], len(m_6[-1]))
  prom(m_6)
func3(function_6, A3[-1], B3[-1], C3[-1], len(m_6[-1]))
lastLine(m_6)

# Постройте таблицу истинности для: 
# 20. A∧B∨B→¬(A∧¬B↔¬A→B∧¬A)
def function_20(A, B):
  C = A and not(B)
  C1 = B and not(A)
  C2 = A or C1
  C3 = (not(C) or C2) and (C or not(C2))
  C4 = not(C3)
  C5 = not((A and B) or B) or C4
  return [int(A), int(B), int(C5)]
m_20 = ['A', 'B', 'A˄B˅B→¬(A˄¬B↔¬A→B˄¬A)']
firstLine(m_20)
prom(m_20)
for i in range(len(A2) - 1):
  func2(function_20, A2[i], B2[i], len(m_20[-1]))
  prom(m_20)
func2(function_20, A2[-1], B2[-1], len(m_20[-1]))
lastLine(m_20)

assert function_4(0, 0) == [0, 0, 0], "При А = 0 и В = 0 (A˅B)˄(¬A˅¬B) != {}".format(0)
assert function_4(0, 1) == [0, 1, 1], "При А = 0 и В = 1 (A˅B)˄(¬A˅¬B) != {}".format(1)
assert function_4(1, 0) == [1, 0, 1], "При А = 1 и В = 0 (A˅B)˄(¬A˅¬B) != {}".format(1)
assert function_4(1, 1) == [1, 1, 0], "При А = 1 и В = 1 (A˅B)˄(¬A˅¬B) != {}".format(0)

assert function_6(0, 0, 0) == [0, 0, 0, 1], "При А = 0, В = 0 и C = 0 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(0, 0, 1) == [0, 0, 1, 1], "При А = 0, В = 0 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(0, 1, 0) == [0, 1, 0, 1], "При А = 0, В = 1 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(0, 1, 1) == [0, 1, 1, 1], "При А = 0, В = 1 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(1, 0, 0) == [1, 0, 0, 1], "При А = 1, В = 0 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(1, 0, 1) == [1, 0, 1, 1], "При А = 1, В = 0 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(1, 1, 0) == [1, 1, 0, 1], "При А = 1, В = 1 и C = 0 ((C˅B)→B)˄(A˄B)→B != {}".format(1)
assert function_6(1, 1, 1) == [1, 1, 1, 1], "При А = 1, В = 1 и C = 1 ((C˅B)→B)˄(A˄B)→B != {}".format(1)

assert function_20(0, 0) == [0, 0, 1], "При А = 0 и В = 0 A˄B˅B→¬(A˄¬B↔¬A→B˄¬A) != {}".format(1)
assert function_20(0, 1) == [0, 1, 1], "При А = 0 и В = 1 A˄B˅B→¬(A˄¬B↔¬A→B˄¬A) != {}".format(1)
assert function_20(1, 0) == [1, 0, 1], "При А = 1 и В = 0 A˄B˅B→¬(A˄¬B↔¬A→B˄¬A) != {}".format(1)
assert function_20(1, 1) == [1, 1, 1], "При А = 1 и В = 1 A˄B˅B→¬(A˄¬B↔¬A→B˄¬A) != {}".format(1)
_______________________________________________________________________________________________________



# 2.2. Разработать программу, которая выводит на экран с помощью ASCII-графики таблицу истинности 
#      на основе переданных ей на вход аргументов (логическое выражение, аргументы, результат 
#      вычисления выражения). Формирование отчета по выполнению задания и размещение его в портфолио, 
#      персональном репозитории. 

_____________________________________________________________________________________________________________
f = ['A', 'B', '¬A', '¬B', 'A˅B', '¬A˅¬B', '(A˅B)˄(¬A˅¬B)']
def func_ist(f):
  # Первая строка таблицы
  print('\u250C', end='')
  for tab in range(len(f) - 1):
    print(('\u2500'*(len(f[tab]) + 2) + '\u252C'), end='')
  print('\u2500'*(len(f[-1]) + 2) + '\u2510')
   # Названия столбцов
  for num in f:
    print('\u2502' + ' ' + num + ' ', end = '')
  print('\u2502')
  # Первые два столбца значений A и B
  A2 = [False, True]
  B2 = [False, True]
  for a in A2:
    for b in B2:
      A = a
      B = b
      # Массив с операциями для сопоставления с массивом f
      f2 = [int(A),int(B),int(not(A)),int(not(B)),int(A or B),int((not(A)) or   (not(B))),int((A or B) and ((not(A)) or (not(B))))]
      Pr = {f[i]: f2[i] for i in range(len(f))}
      # Промежуточная страка таблицы без значений
      print('\u251C', end ='')
      for tab in range(len(f) - 1):
        print(('\u2500'*(len(f[tab]) + 2) + '\u253C'), end='')
      print('\u2500'*(len(f[-1]) + 2) + '\u2524')
      # Заполнение строк значениями
      print('\u2502', end = '')
      for i in range(len(f) - 1):
        print(' ' * ((len(f[i]) + 2)//2), end='')
        print(Pr[f[i]], end='')
        print(' ' * (len(f[i]) + 1 - (len(f[i]) + 2)//2), end='')
        print('\u2502', end = '')
      print(' ' * ((len(f[-1]) + 2)//2), end='')
      print(Pr[f[-1]], end='')
      print(' ' * (len(f[-1]) + 1 - (len(f[-1]) + 2)//2), end='')
      print('\u2502')
  # Последняя строка таблицы
  print('\u2514', end='')
  for tab in range(len(f) - 1):
    print(('\u2500'*(len(f[tab]) + 2) + '\u2534'), end='')
  print('\u2500'*(len(f[-1]) + 2) + '\u2518')

func_ist(f)
_____________________________________________________________________________________________________________

# 2.3. Разработать скрипт с функцией, которая для ряда Фибоначчи, где количество элементов, n = 22, 
#      возвращает подмножество значений или единственное значение (по вариантам). Для нахождения 
#      элемента требуется использовать слайсы. Формирование отчета по выполнению задания и размещение
#      его в портфолио, персональном репозитории. 

lst = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946]

# Сумму элементов, расположенных на нечетных позициях, второй половины списка.
print(sum(lst[len(lst) // 2::][::2]))

# Сумму всех элементов списка с элементами, стоящими на четных позициях в его второй половине.  
print(sum(lst[len(lst) // 2::][1::2]) + sum(lst))

# Сумму четных элементов (со второго по предпоследний элемент) списка.
#print(lst[1:len(lst) - 1:])
k = 0
for i in lst[1:len(lst)- 1:]:
     if (i % 2 == 0):
         k += i
print(k)

# Сумму нечетных элементов (с пятого по предпредпоследний элемент) списка.
#print(lst[4:len(lst) - 2:])
k = 0
for i in lst[4:len(lst)- 2:]:
     if (i % 2 == 1):
         k += i
print(k)

# Сумму элементов, расположенных на четных позициях, первой половины списка.
print(sum(lst[:len(lst) // 2:][1::2]))

# Сумму элементов, расположенных на нечетных позициях, второй половины списка.
print(sum(lst[len(lst) // 2::][::2]))

# Максимальный элемент, стоящий на четной позиции среди элементов второй половины списка.
print(max(lst[len(lst) // 2::][1::2]))

# Минимальный элемент, стоящий на нечетной позиции среди элементов первой половины списка.
print(min(lst[:len(lst) // 2:][::2]))

# Список элементов, стоящих на четных позициях во второй половине списка в обратном порядке.
print(lst[len(lst) // 2::][-2::-2])

# 2.4. Напишите программу с функцией, в которой будет реализовано решение физической задачи (по вариантам).
#      Например: ящик, имеющий форму куба с ребром a см без одной грани, нужно покрасить со всех сторон
#      снаружи. Найдите площадь поверхности, которую необходимо покрасить. Ответ дайте в квадратных 
#      сантиметрах. Решение задачи оформите в виде функции square(a), которая возвращает значение s. 
#      Например, при значении a = 30, square(30) вернет s = 4500. Формирование отчета по выполнению задания
#      и размещение его в портфолио, персональном репозитории.
